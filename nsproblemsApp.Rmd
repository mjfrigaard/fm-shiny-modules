---
title: "nsproblemsApp: (an app without modules)"
author: "Martin Frigaard"
output:
  html_document: 
    highlight: tango
    theme: darkly
    source_code: embed
    toc: true
    toc_float: yes
    df_print: paged
    
runtime: shiny
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)
library(tidyverse)
library(devtools)
library(hrbrthemes)
library(fs)
library(shiny)
library(reactable)
library(rmarkdown)
# Global options
knitr::opts_chunk$set(
  # cache = FALSE # cache data
  echo = TRUE, # show/hide all code
  # results = "hide", # hide results
  tidy = FALSE, # cleaner code printing
  comment = "#> ", # better console printing
  eval = TRUE, # turn this to FALSE stop code chunks from running
  message = TRUE, # show messages
  warning = FALSE, # show warnings
  size = "tiny", # size of the text
  fig.path = "images", # location of figure files
  fig.height = 7.5, # height of figures
  fig.width = 10 # width of figures
)
# knit options
knitr::opts_knit$set(
  width = 78,
  progress = FALSE
)
# base options
base::options(
  tibble.print_max = 25,
  tibble.width = 78,
  max.print = 999999,
  scipen = 100000000
)
```

Welcome! `fm-shiny-modules` is a series of shiny apps that demonstrate the benefit of using modules. I've also included some explanations, figures, and resources that helped me understand how modules work. 

# Background

When I first started creating shiny applications, I assumed complexity was a inherent feature of their design. Even if I separated the app into `ui.R` and `server.R` scripts, it quickly became hard to manage all the inputs, reactives, and outputs.

I experimented with modules for awhile, but the concepts didn't start to click until shiny [version 1.5.0](https://shiny.rstudio.com/articles/modules.html) with the introduction of the [`moduleServer()`](https://shiny.rstudio.com/reference/shiny/1.7.0/moduleServer.html) function. This function (along with the `NS()` function) helped me understand the purpose of modules (and the problem(s) they solve).

# An example of the problem

First we're going to create a shiny app *without* modules using data from the [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/) package. 

This application will build a plot and display a table of three variables from the `penguins` data. The plot is built using [`ggplot2`](https://ggplot2.tidyverse.org/), and the table is built using the [`reactable` package](https://glin.github.io/reactable/). We'll display the reactive values within the application using methods described [here](https://mjfrigaard.shinyapps.io/reactiveValuesApp/).

We will build this app in separate `ui.R` and `server.R` files. Check those out [here](https://github.com/mjfrigaard/shinymods/tree/main/01-problemShinyApp).

## ui.R

In the UI, we'll add `inputId`'s for the graph and table outputs. We'll also include labels in the comments for each of input `(graph)` and `(table)`, and add a `"value"` output (with `verbatimTextOutput()`) for our reactive values.

```{r ui-r-nsproblemsApp}
library(shiny)
library(tidyverse)
library(palmerpenguins)
library(reactable)

ui <- fluidPage(title = "nsproblemsApp",
  sidebarLayout(
    sidebarPanel(
      # x variable graph
      selectInput(
        inputId = "x_var",
        label = "X column (graph)",
        selected = "body_mass_g",
        choices = names(
          select(
            palmerpenguins::penguins, where(is.numeric)
          )
        )
      ),
      # x variable table
      selectInput(
        inputId = "x_var",
        label = "X column (table)",
        selected = "body_mass_g",
        choices = names(palmerpenguins::penguins)
      ),
      # y variable graph
      selectInput(
        inputId = "y_var",
        label = "Y column (graph)",
        selected = "bill_length_mm",
        choices = names(
          select(
            palmerpenguins::penguins, where(is.numeric)
          )
        )
      ),
      # y variable table
      selectInput(
        inputId = "y_var",
        label = "Y column (table)",
        selected = "bill_length_mm",
        choices = names(palmerpenguins::penguins)
      ),
      # color graph
      selectInput(
        inputId = "color",
        label = "Color column (graph)",
        selected = "species",
        choices = names(
          select(
            palmerpenguins::penguins, where(is.factor)
          )
        )
      ),
      # color table
      selectInput(
        inputId = "color",
        label = "Color column (table)",
        selected = "species",
        choices = names(palmerpenguins::penguins)
      )
    ),
    mainPanel(
      # plot
      plotOutput(outputId = "plot"),
      br(), br(),
      reactableOutput(outputId = "table"),
      # values
      tags$strong(tags$code("reactiveValues:")),
      verbatimTextOutput(outputId = "value")
    )
  )
)
```

*If you're somewhat familiar with shiny code, you're immediately wondering how shiny is going to handle this duplication of names (as you should). But, since this application is meant to demonstrate namespace collisions, we're purposely designing it with some known issues.*

## server.R

In the `server.R`, we'll create the `data()` reactive and use it in both the `output$plot` and `output$table`. We'll also add the `reactiveValuesToList()` function, which will create a list of all the values in the `reactivevalues` object (within a particular namespace). 

```{r server-r-nsproblemsApp}
library(shiny)
library(tidyverse)
library(palmerpenguins)
library(reactable)

server <- function(input, output, session) {
  # data
  data <- reactive(
    select(
      palmerpenguins::penguins,
      all_of(c(input$x_var, input$y_var, input$color))
    )
  )

  # plot display
  output$plot <- renderPlot({
    # y labels
    y_lab <- str_replace_all(input$y_var, "_", " ")
    # x labels
    x_lab <- str_replace_all(input$x_var, "_", " ")
    # graph
    ggplot(data()) +
      geom_point(aes_string(
        x = input$x_var, 
          y = input$y_var,
        color = input$color
      )) +
      labs(
        title =
          paste0("Histogram of ", x_lab, " and ", y_lab),
        x = x_lab,
        y = y_lab
      )
  })

  # table display
  output$table <- reactable::renderReactable({
    reactable::reactable(
      data = data(),
      defaultPageSize = 10,
      resizable = TRUE,
      highlight = TRUE,
      height = 350,
      wrap = FALSE,
      bordered = TRUE,
      searchable = TRUE,
      filterable = TRUE
    )
  })

  # reactive values
  output$value <- renderPrint({
    all_values <- reactiveValuesToList(x = input, all.names = TRUE)
    values <- all_values[str_detect(names(all_values), "color|x_var|y_var")]
    print(values)
  })
}
```

# App

The deployed application is here: 

```{r deploy-app, echo=FALSE}
shinyApp(ui = ui, server = server, 
         options = list(height = 1100, width = 800))
```


## App overview

This application has both the plot and table outputs, and six `selectInputs()`s for controlling the variables in the outputs (labeled **(table)** and **(graph)**). 

```{r plotdata-ui-server-png, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/plotdata-ui-server.png")
```

To test the reactivity, we're going to change the variable for **X column (graph)** to `bill_depth_mm`. We should see the graph change (and we do):

```{r plotdata-ui-server-x_var-png, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/plotdata-ui-server-x_var.png")
```

However, we also see the data in the table display change (even though we didn't change this input): 

```{r plotdata-ui-server-x_var-table-png, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/plotdata-ui-server-x_var-table.png")
```

## Execution order

*Why did the table change even though we didn't change the input?*  Well, the answer is covered here in the '[execution order](https://mastering-shiny.org/basic-reactivity.html#execution-order)' section of Mastering Shiny: 

***the order in which reactive code is run is determined only by the reactive graph, not by its layout in the server function.*** 

Recall the [reactive expression graph](https://mastering-shiny.org/basic-reactivity.html#reactive-expressions-1) from Mastering Shiny below: 

![](https://d33wubrfki0l68.cloudfront.net/8dcc3f2cbc55486a76b33a5acd30e379cd05d8ab/27c40/diagrams/basic-reactivity/producers-consumers.png)

`graph` has a reactive dependency on `x_var`:

```{r reactive-dependencypng, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/reactive-dependency.png")
```

When we include the reactive expression in the graph, `input$x_var` and `data()` are the **Producers**, while `data()` and `output$graph` are the **Consumers**.

So, the `input$x_var` value in the graph changes when we select `bill_depth_mm`, and `data()` is changed in both `output$graph` *and* `output$table`. The table is only updated when the reactable `data()` is changed (i.e. when the graph uses these values explicitly in `aes_string(x = input$x_var)`). 

```{r producers-consumers, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/producers-consumers.png")
```

Furthermore, when we changed the **X column (graph)**, the `input$x_var` value is 'taken' and updated in the graph (see the solid lines in the figure below). The `input$x_var` for **X column (table)** is ignored (see the dashed lines in the figure below) and the reactable table is not updated.

```{r plotdata-ui-server-x_var-data-png, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/plotdata-ui-server-x_var-data.png")
```

If we check the the `reactiveValues` output, we can see there is only one column associated with the `$x_var` input (`bill_depth_mm`):

```{r plotdata-ui-server-x_var-values-png, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/plotdata-ui-server-x_var-values.png")
```

## Highlighting the problem 

If we deployed these apps using `display.mode = "showcase"` then we could see the `output$graph` and `output$table` light up when we change the **X column (graph)**:

```{r plotdataApp-x_var-gif, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/plotdataApp-x_var.gif")
```

When we check the additional `selectInput()`s, we can see that only the values for **(graph)** trigger the code in the server (none of the values for **(table)** trigger a response).

```{r plotdataApp-x_var-no-reaction-gif, echo=FALSE, eval=TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/mjfrigaard/shinymods/main/img/plotdataApp-x_var-no-reaction.gif")
```

# Recap

This application demonstrates the issue of having duplicate ID's in the same namespace. As noted [here](https://shiny.rstudio.com/articles/modules.html), "*Input and output IDs in Shiny apps share a global namespace, meaning, each ID must be unique across the entire app.*" In this application, we purposely created the application with duplicate IDs (`x_var`, `y_var`, and `color`) to demonstrate how this can cause problems with reactivity. As we can see, the IDs get used according to the *execution order in the reactive graph*, and not the way the code is organized in the server. 

In the next app, we're going to build a shiny module to handle this namespace issue. 